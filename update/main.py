#!/usr/bin/env python3

"""
QAOA Simulation

For MAXCUT optimization on simulated quantum circuits, estimates cost function
 gradient magnitudes.
"""

import numpy as np

def set_simulation_constants():
    """
    Generates constants and labels used in simulation.
    """
    NUM_TRIALS = 10
    SIZE_RANGE = range(4, 11)
    ERROR_RATES = ["0%", "3%", "5%", "10%", "15%"]
    MAX_FOLD = 4

    # For each error rate, we want to include a label for the "synthetic" noise 
    #  levels generated by adding more noise (i.e., via unitary folding). We do 
    #  this even for an error rate of 0%; in general, we would not perform ZNE
    #  on an already noise-free result, but we include it as a sanity check.
    NOISE_LEVELS = ERROR_RATES[:]
    for error_rate in ERROR_RATES:
        folded_noise_levels = [error_rate + " fold x" + str(folding_factor)
                               for folding_factor in range(MAX_FOLD + 1)
                               if folding_factor > 1]
        NOISE_LEVELS.extend(folded_noise_levels)

    return NUM_TRIALS, SIZE_RANGE, ERROR_RATES, MAX_FOLD, NOISE_LEVELS 


class Data():
    def __init__(self, constants):
        """
        """
        NUM_TRIALS, SIZE_RANGE, ERROR_RATES, MAX_FOLD, NOISE_LEVELS = constants
        self.raw_data = np.zeros(shape=(len(SIZE_RANGE), NUM_TRIALS,
                                        len(NOISE_LEVELS))) 


def main():
    """
    Simulates MAXCUT optimization (i.e., computing cost function values by
     simulating execution of quantum circuits).
    """
    # Generates empty dataset large enough to store all possible data. Access
    #  data elements by index, where each field (circuit width, trial, noise
    #  level) is mapped to an index (i.e., data[circuit width][trial][noise
    #  level]).
    constants = set_simulation_constants()
    data = Data(constants)


if __name__ == "__main__":
    main()
