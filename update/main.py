#!/usr/bin/env python3

"""
QAOA Simulation

For MAXCUT optimization on simulated quantum circuits, estimates cost function
 gradient magnitudes.
"""

import numpy as np
import networkx as nx

class Data():
    """
    Stores raw data and includes methods to extract processed data.
    """
    def __init__(self):
        constants = self.set_simulation_constants()
        NUM_TRIALS, CIRCUIT_SIZES, ERROR_RATES, MAX_FOLD, NOISE_LVLS = constants
        self.num_trials = NUM_TRIALS
        self.circuit_sizes = CIRCUIT_SIZES
        self.error_rates = ERROR_RATES
        self.max_fold = MAX_FOLD
        self.noise_levels = NOISE_LVLS
        self.raw_data = np.zeros(shape=(len(CIRCUIT_SIZES), NUM_TRIALS,
                                        len(NOISE_LVLS))) 

    def set_simulation_constants(self):
        """
        Generates constants and labels used in simulation.
        """
        NUM_TRIALS = 10
        CIRCUIT_SIZES = range(4, 11)
        ERROR_RATES = ["0%", "3%", "5%", "10%", "15%"]
        MAX_FOLD = 4
    
        # For each error rate, we want to include a label for the "synthetic"
        #  noise levels generated by adding more noise (i.e., via unitary
        #  folding). We do this even for an error rate of 0%; in general, we
        #  would not perform ZNE on an already noise-free result, but we include
        #  it as a sanity check.
        NOISE_LEVELS = ERROR_RATES[:]
        for error_rate in ERROR_RATES:
            folded_noise_levels = [error_rate + " fold x" + str(folding_factor)
                                   for folding_factor in range(1, MAX_FOLD + 1)]
            NOISE_LEVELS.extend(folded_noise_levels)
    
        return NUM_TRIALS, CIRCUIT_SIZES, ERROR_RATES, MAX_FOLD, NOISE_LEVELS 


class RandomCircuit():
    """
    Random quantum circuit built using Erdor-Renyi model.
    """
    def __init__(self, num_qubits, gate_parameters):
        EDGE_PROBABILITY = 0.5
        self.num_qubits = num_qubits
        self.gate_parameters = gate_parameters
        connectivity = self.create_connectivity(num_qubits, EDGE_PROBABILITY)
        self.connectivity = connectivity
        self.circuit = self.build_circuit(connectivity, gate_parameters)


    def create_connectivity(self, num_qubits, edge_probability):
        """
        Builds Erdos-Renyi graph (random graph) representing circuit
         connectivity.
        """
        graph = nx.erdos_renyi_graph(num_qubits, edge_probability)
        for edge in graph.edges:
            graph[edge[0]][edge[1]]["weight"] = 1.0
        return graph


    def build_circuit(self, connectivity, gate_parameters):
        """
        Given connectivity, build QAOA circuit.
        """
        gamma, beta = gate_parameters
        #TODO:


class Trial():
    """
    Builds and executes necessary circuit elements for a single simulation
     trial.
    """
    def __init__(self, circuit_size, noise_levels):
        gate_parameters = self.get_gate_parameters()
        self.gate_parameters = gate_parameters
        self.circuit = RandomCircuit(circuit_size, gate_parameters)
        self.circuit_size = circuit_size
        self.noise_levels = noise_levels


    def get_gate_parameters(self):
        """
        Initialize new random gate parameters, gamma and beta.
        """
        #TODO:
        return 0.0, 0.0


    def run(self):
        """
        Iterates over given noise levels and runs QAOA simulation given
         circuit size and noise level.
        """
        #TODO:
        pass


def simulate(data):
    """
    Runs QAOA simulation for a range of circuit sizes (i.e., circuit width, numb     er of qubits), updating given data structure.
    """
    # Iterate over range of circuit sizes, building Erdos-Renyi graph for each
    #  size.
    num_trials = data.num_trials
    circuit_sizes = data.circuit_sizes
    noise_levels = data.noise_levels
    for circuit_size in circuit_sizes:

        # Per circuit size, iterates over a given number of trials.
        trial_object = Trial(circuit_size, noise_levels)
        for trial in range(num_trials):

            # Per trial, iterates over a given number of error rates and runs
            #  QAOA simulation given circuit size and error rate.
            trial_object.run()


def main():
    """
    Simulates MAXCUT optimization (i.e., computing cost function values by
     simulating execution of quantum circuits).
    """
    # Generates empty dataset large enough to store all possible data. Access
    #  data elements by index, where each field (circuit width, trial, noise
    #  level) is mapped to an index (i.e., data[circuit width][trial][noise
    #  level]).
    data = Data()
    simulate(data)


if __name__ == "__main__":
    main()
